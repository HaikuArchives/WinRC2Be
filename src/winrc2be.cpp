/* winrc2be.cpp - Parser
 *
 * w32rc2be - Beta 8 - Oct. 18, 2002
 * For conditions of distribution and use, see copyright notice in license file
 * Copyright (c) 1991-2002 realtech VR
 *
 * This file provides MS Visual C++ 6 Resource Parsing
 */

#include <ctype.h>
#include <assert.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *line_mark = "/////////////////////////////////////////////////////////////////////////////";
#define __VER__ "Beta 8"
#define __BUILD__ "WinRC2Be "__VER__" Build "__DATE__" - http://www.realtech-vr.com"
static const char *copyright = "// Generated by "__BUILD__"\n";

struct RCRect
{
	float left, 
		  top, 
		  right, 
		  bottom;
};

static char			g_szCurrentFile[256];
static int			g_nCurrentLine;
static int			g_iCurrentStack = 0;
static float		g_fUIScaleX = 1.5f, 
					g_fUIScaleY = 1.5f;
static bool			g_bHasMenu;
static bool			g_bHasBitmaps = false, 
					g_bHasIcons = false;
static bool			g_bForceOverwrite;
static float		g_iOffsetX, 
					g_iOffsetY;

#define MENU_YSIZE 15

static char *fixingWINString(char *filename)
{
	char temp[256];
	char *t = temp;
	char *s = filename;
	while (*s)
	{
		if (*s=='&') 
		{
			*t = '&';
			t++;
			s++;
		}
		else
		{
			*t = *s;
			t++;
		}		
		s++;
	}
	*t = 0;
	strcpy(filename, temp);
	return filename;
}

static char *fixingBMPFilename(char *filename)
{
	char temp[256];
	char *t = temp;
	char *s = filename;
	while (*s)
	{
		if (*s=='\\') 
		{
			*t = '/';
			t++;
			s++;
		}
		else
		{
			*t = *s;
			t++;
		}		
		s++;
	}
	*t = 0;
	strcpy(filename, temp);
	return filename;
}			

void WriteNext(FILE *fp, int first, const char *pIDC)
{
	if (!first)
	{
		fprintf(fp, "\t\t\tpCurrent->next->ID = %s;\n", pIDC);
		fprintf(fp, "\t\t\tpCurrent = pCurrent->next;\n");
	}
	else
	{
		fprintf(fp, "\t\t\tpCurrent->ID = %s;\n", pIDC);
	}
}

enum { 
	 ORDER_ROOT , 
	 ORDER_CHILD
};


class	RCView;
RCRect	g_pViewRect;

class RCItem {
	public:
		RCItem(int i, const char *IDC) : owner(g_pViewRect), order(i)
		{
			strcpy(pIDC, IDC);
			memset(&rect, 0, sizeof(rect));
		}

		virtual ~RCItem()
		{
		}

		virtual bool Write(FILE *fp, int first, int next ) = 0;

		const char *GetFollowMode()
		{
			static char mode[128];
			strcpy(mode, "B_FOLLOW_ALL");			
			/*
				compare rect vs owner->rect;

			*/

			return mode;
		}

		RCItem *pNext;
		RCRect rect, owner;
		int order;
		char pIDC[256];
};

class RCItem1 : public RCItem {
	public:
		RCItem1(int order, const char *ID, const char *pS) : RCItem(order, ID)
		{
			strcpy(pString, pS);
		}		
		char pString[256];
};

class RCItem_Menu : public RCItem {
	public:
		RCItem_Menu(const char *ID) : RCItem(ORDER_CHILD, ID)
		{
		}
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(LoadMenu(%s), -1);\n", 
			s, 
			pIDC);
			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
};


class RCItem2 : public RCItem {
	public:
		RCItem2(int order, const char *ID, int x, int y, int lx, int ly) : RCItem(order, ID)
		{
			rect.left = float(x) * g_fUIScaleX;
			rect.right = float(x + lx)* g_fUIScaleX;
			if (g_bHasMenu)
				y+=MENU_YSIZE;
			rect.top = float(y)* g_fUIScaleY;
			rect.bottom = float(y + ly)* g_fUIScaleY;
		}
		
};

class RCItemEx : public RCItem {
	public:
		RCItemEx(int order, const char *ID, const char *pS, int x, int y, int lx, int ly) : RCItem(order, ID)
		{
			strcpy(pString, pS);
			rect.left = float(x) * g_fUIScaleX;
			rect.right = float(x + lx)* g_fUIScaleX;
			
			if (g_bHasMenu)
				y+=MENU_YSIZE;

			rect.top = float(y)* g_fUIScaleY;
			rect.bottom = float(y + ly)* g_fUIScaleY;
		}
		
		char pString[256];
		
};

class RCBitmapEntry {
	public:
		RCBitmapEntry(const char *IDC, const char *filename)
		{
			strcpy(pIDC, IDC);
			strcpy(pFilename, filename);
			pNext = 0;
		}
		RCBitmapEntry()
		{
			pNext = 0;
		}
		void Write(FILE *fp)
		{
			fprintf(fp, "\t\tcase %s : return \"%s\";\n", pIDC, pFilename);
		}
		RCBitmapEntry *pNext;
		char pIDC[256];
		char pFilename[256];
};


class RCBitmap {
	public:
		RCBitmap()
		{
			pFirst = pCurrent = 0;
		}

		~RCBitmap()
		{
			pCurrent = pFirst;
			while (pCurrent)
			{
				RCBitmapEntry *n = pCurrent->pNext;
				delete pCurrent;
				pCurrent = n;
			}
		}
		
		void AddEntry(RCBitmapEntry *item)
		{
			if (!pCurrent)
			{
				pCurrent = pFirst = item;

			}
			else
			{
				pCurrent->pNext = item;
				pCurrent = item;
			}
			pCurrent->pNext = 0;
		}
		RCBitmapEntry *pFirst, *pCurrent;
		
};


enum {
	MN_DEBUT, 
	MN_FIRST, 
	MN_SEPARATOR, 
	MN_BEGIN, 
	MN_BEGINBAR, 
	MN_END, 
	MN_ITEM, 
	MN_POPUP
};

class RCMenuEntry {
	public:
		RCMenuEntry(const char *IDC, const char *filename)
		{
			strcpy(pIDC, IDC);
			strcpy(pFilename, filename);
			pNext = 0;
			type = MN_ITEM;
		}
		~RCMenuEntry()
		{

		}

		RCMenuEntry(int t)
		{
			pNext = 0;
			
			type = t;			
		}
		RCMenuEntry(int t, const char *filename)
		{
			pNext = 0;
			strcpy(pFilename, filename);
			type = t;			
		}
		void Write(FILE *fp)
		{
			static int stack;
			switch(type) {
				case MN_POPUP:
					/*
					fprintf(fp, "\t\t\tpFirst->AddItem(new BMenuItem(\"%s\", new BMessage('bar')));\n", 
						 pFilename
					);
					*/
				break;
				case MN_DEBUT:					
					fprintf(fp, "\t\t\tBMenu *pMenu, *pFirst, *pPrev[%d];\n", g_iCurrentStack);
				break;
				case MN_FIRST:					
					fprintf(fp, "\t\t\tpMenu = pFirst = pPrv[0] = new BMenu();\n");
				break;
				case MN_SEPARATOR:
					fprintf(fp, "\t\t\tpMenu->AddItem(new BSeparatorItem);\n");
				break;
				case MN_BEGIN:
					fprintf(fp, "\t\t\tpPrev[%d] = pMenu ; pMenu = new BMenu(\"%s\"); pPrev[%d]->AddItem(pMenu);\n", stack, pFilename, stack);
					stack++;
				break;
				case MN_BEGINBAR:
					fprintf(fp, "\t\t\tpFirst = pMenu = new BMenuBar(BRect(0, 0, 8, 8), \"%s\"); \n", pFilename);
					
				break;
				case MN_END:
					stack--;
					if (stack>=0)
					fprintf(fp, "\t\t\tpMenu = pPrev[%d] ;\n", stack);
					
				break;
				case MN_ITEM:
					fprintf(fp, "\t\t\tpMenu->AddItem(new BMenuItem(\"%s\", new BMessage(%s)));\n", 
						pFilename, 
						pIDC
					);
				break;
				default:
				break;
			}
		}
		RCMenuEntry *pNext;
		char pIDC[256];
		char pFilename[256];
		int type;
};


class RCMenu {
	public:
		RCMenu() : pFirst(0), pCurrent(0), pNext(0)
		{
		}
		RCMenu(const char *pname)
		{
			pFirst = pCurrent = 0;
			pNext = 0;			
			strncpy(name, pname, 255);
			AddEntry(new RCMenuEntry(MN_DEBUT));
		}
		~RCMenu()
		{
			RCMenuEntry *i = pFirst;
			while (i)
			{
				RCMenuEntry *n = i->pNext;
				delete i;
				i = n;
			}
			return;
		}		
		
		void AddEntry(RCMenuEntry *item)
		{
			if (!pCurrent)
			{
				pCurrent = pFirst = item;

			}
			else
			{
				pCurrent->pNext = item;
				pCurrent = item;
			}
			pCurrent->pNext = 0;
		}
		void Write(FILE *fp)
		{
			RCMenuEntry *p = pFirst;			
		
			fprintf(fp, "\t\tcase %s:\n", name);	
			fprintf(fp, "\t\t{\n");	
			while (p)
			{
				p->Write(fp);
				p = p->pNext;
			}
			fprintf(fp, "\t\t\treturn pFirst;\n");
			fprintf(fp, "\t\t}\n");	
			fprintf(fp, "\t\tbreak;\n");	
			
		}
		RCMenuEntry *pFirst, *pCurrent;
		RCMenu *pNext;
		char name[256];
		
};

class RCView {
	public:
		RCView()
		{
			IsWindow = false;
			pCurrent = 0;
		}
	
		RCView(const char *IDC, const char *layout)
		{
			strcpy(pIDC, IDC);
			strcpy(pLayout, layout);
			IsWindow = false;
			pCurrent = 0;
		}
		RCView(const char *IDC, int x, int y, int lx, int ly, const char *title, bool center, const char *look, const char *feel, const char *resize, const char *pmenu) : pFirst(0)
		{
			strcpy(pIDC, IDC);
			strcpy(pTitle, title);
			strcpy(pFeel, feel);
			strcpy(pLook, look);
			strcpy(pResize, resize);
			pCenter = center;
			pCurrent = 0;
			pNext = 0;
			style = 0;
			rect.left = (x) * g_fUIScaleX;
			rect.right = (x + lx)* g_fUIScaleX;
			rect.top = (y)* g_fUIScaleY;
			rect.bottom = (y + ly)* g_fUIScaleY;
			IsWindow = true;
			if (*pmenu)
			{
				Add(new RCItem_Menu(pmenu));
				g_bHasMenu = true;
				rect.bottom+=MENU_YSIZE * g_fUIScaleY;
			}
			else
				g_bHasMenu = false;
			
		}
		virtual ~RCView()
		{
			RCItem *i = pFirst;
			while (i)
			{
				RCItem *n = i->pNext;
				delete i;
				i = n;
			}
			return;
		}
		virtual void Write(FILE *fp)
		{
			RCItem *i = pFirst;	
			int cnt = 1;
			
			fprintf(fp, "\t\tcase %s :\n", pIDC);
			fprintf(fp, "\t\t{\n");
			fprintf(fp, "\t\t\tRViewList *pCurrent, *pFirst;\n");

			int next = -1;
			int n = 0;
			g_iOffsetX = 0;
			g_iOffsetY = 0;
			while (i)
			{
				
				if (i->order == ORDER_ROOT) 
				{
					next = -1;					
					g_iOffsetX = 0;
					g_iOffsetY = 0;
				}
				
				i->Write(fp, cnt, next);
				if (i->order == ORDER_ROOT) 
				{
					next = n;
					g_iOffsetX = -i->rect.left;
					g_iOffsetY = -i->rect.top;
				}
				i = i->pNext;
				cnt = 0;
				n++;
			}
			if (!cnt)
			{
				fprintf(fp, "\t\t\tpCurrent->next = 0;\n");
			}
			fprintf(fp, "\t\t\treturn pFirst;\n");
			fprintf(fp, "\t\t}\n");
			
			return;
		}
		void Add(RCItem *item)
		{
			if (!pCurrent)
			{
				pCurrent = pFirst = item;

			}
			else
				{
				pCurrent->pNext = item;
				pCurrent = item;
			}
			pCurrent->pNext = 0;
		}
		
		bool		IsWindow;
		RCRect		rect;
		unsigned	style;	
		RCItem		*pFirst;
		RCItem		*pCurrent;
		char		pIDC[256];
		char        pTitle[256];
		char        pLook[32];
		char        pFeel[32];
		char        pResize[32];
		char		pLayout[32];
		bool        pCenter;
		RCView		*pNext;
		
};

class RCItem_Text : public RCItemEx  {
	public:
		RCItem_Text(const char *ID, const char *pS, int x, int y, int lx, int ly, const char *alignement) : RCItemEx(ORDER_CHILD, ID, pS, x, y, lx, ly)
		{
			strcpy(szAlignement, alignement);

		}
		bool Write(FILE *fp, int first , int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t{ BStringView *_b = new BStringView( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", \"%s\", %s, B_WILL_DRAW); _b->SetAlignment(%s); %s = new RViewList(_b, %d); }\n", 			
			rect.left + g_iOffsetX, rect.top + g_iOffsetY, rect.right + 4 + g_iOffsetX, rect.bottom + g_iOffsetY, 
			pIDC, 
			pString, 
			GetFollowMode(),
			szAlignement,
			s, next);			

			WriteNext(fp, first, pIDC);
			return true;
			
		}
		char szAlignement[32];
};


class RCItem_PushButton : public RCItemEx {
	public:
		RCItem_PushButton(const char *ID, const char *pS, int x, int y, int lx, int ly, bool bisDefault, bool bEnabled) : RCItemEx(ORDER_CHILD, ID, pS, x, y, lx, ly), isDefault(bisDefault), isEnabled(bEnabled)
		{
		}
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t { BButton *_b = new BButton( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", \"%s\", new BMessage(%s), %s, B_WILL_DRAW | B_NAVIGABLE ); %s = new RViewList(_b, %d); _b->MakeDefault(%s); _b->SetEnabled(%s);}\n", 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			pString, 
			pIDC, 
			GetFollowMode(),
			s, next, 
			isDefault ? "true" : "false",
			isEnabled ? "true" : "false");

			WriteNext(fp, first, pIDC);
			return true;
			
		}
		bool isDefault;
		bool isEnabled;

};



class RCItem_GroupBox : public RCItemEx {
	public:
		RCItem_GroupBox(const char *ID, const char *pS, int x, int y, int lx, int ly) : RCItemEx(ORDER_ROOT, ID, pS, x, y, lx, ly)
		{
		}
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
    		const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;
//			const char *ss = first ? s3 : s2;

			fprintf(fp, "\t\t\t{ BBox *b = new BBox( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\"); b->SetLabel(\"%s\"); %s = new RViewList(b, %d); } \n", 
			
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pString, 
			pString, 
			s, next
			);
			WriteNext(fp, first, pIDC);			
			
			return true;
			
		}
};
		
class RCItem_CheckBox : public RCItemEx {
	public:
		RCItem_CheckBox(const char *ID, const char *pS, int x, int y, int lx, int ly, bool b) : RCItemEx(ORDER_CHILD, ID, pS, x, y, lx, ly), m_enabled(b)
		{
		}
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new BCheckBox( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", \"%s\", new BMessage(%s), %s, B_WILL_DRAW | B_NAVIGABLE ), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			pString, 
			GetFollowMode(),
			pIDC, next);

			WriteNext(fp, first, pIDC);
			
			
			return true;
			
		}
		bool m_enabled;
};

class RCItem_RadioButton : public RCItemEx {
	public:
		RCItem_RadioButton(const char *ID, const char *pS, int x, int y, int lx, int ly, bool bEnabled) : RCItemEx(ORDER_CHILD, ID, pS, x, y, lx, ly), m_enabled(bEnabled)
		{
		}
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new BRadioButton( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", \"%s\", new BMessage(%s), %s, B_WILL_DRAW | B_NAVIGABLE), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			pString, 
			pIDC, 
			GetFollowMode(),
			next);

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
		bool m_enabled;
		
};


class RCItem_Bitmap: public RCItemEx {
	public:
		RCItem_Bitmap(const char *ID, const char *pS, int x, int y, int lx, int ly) : RCItemEx(ORDER_CHILD, ID, pS, x, y, lx , ly)
		{
			g_bHasBitmaps = true;
		}
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new RBitmapView( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", %s, LoadBitmapResource(%s)), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			GetFollowMode(),
			pString, next);

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
		bool m_enabled;
};

class RCItem_Icon: public RCItemEx {
	public:
		RCItem_Icon(const char *ID, const char *pS, int x, int y, int lx, int ly) : RCItemEx(ORDER_CHILD, ID, pS, x, y, lx , ly)
		{
			g_bHasIcons = true;
		}
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new RBitmapView( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", %s, LoadIconResource(%s)), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			GetFollowMode(),
			pString, next);

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
		bool m_enabled;
};

class RCItem_OutlistBox : public RCItem2 {
	public:
		RCItem_OutlistBox(const char *ID, int x, int y, int lx, int ly) : RCItem2(ORDER_CHILD, ID, x, y, lx, ly)
		{
		}		
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new BOutlineListView( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", B_MULTIPLE_SELECTION_LIST, %s), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			GetFollowMode(),
			next );

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
		bool m_enabled;
};

class RCItem_StatusBar : public RCItem2 {
	public:
		RCItem_StatusBar(const char *ID, int x, int y, int lx, int ly) : RCItem2(ORDER_CHILD, ID, x, y, lx, ly)
		{
		}		
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new BStatusBar( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\"), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			next );

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
		bool m_enabled;
};


class RCItem_ListView : public RCItem2 {
	public:
		RCItem_ListView(const char *ID, int x, int y, int lx, int ly) : RCItem2(ORDER_CHILD, ID, x, y, lx, ly)
		{
		}		
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new BListView( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", B_MULTIPLE_SELECTION_LIST, %s), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			GetFollowMode(),
			next );

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
		bool m_enabled;
};

class RCItem_Slider : public RCItem2 {
	public:
		RCItem_Slider(const char *ID, int x, int y, int lx, int ly, bool b) : RCItem2(ORDER_CHILD, ID, x, y, lx, ly), m_enabled(b)
		{
		}		
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new BSlider( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", \"\", new BMessage(%s), 0, 100, B_TRIANGLE_THUMB, %s), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, pIDC, 
			GetFollowMode(),
			next );

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
		bool m_enabled;
};


class RCItem_ListBox : public RCItem2 {
	public:
		RCItem_ListBox(const char *ID, int x, int y, int lx, int ly) : RCItem2(ORDER_CHILD, ID, x, y, lx, ly)
		{
		}		
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new BListView( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", B_SINGLE_SELECTION_LIST, %s, B_WILL_DRAW | B_NAVIGABLE | B_FRAME_EVENTS), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			GetFollowMode(),
			next );

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
};

class RCItem_ComboBox : public RCItem2 {
	public:
		RCItem_ComboBox(const char *ID, int x, int y, int lx, int ly) : RCItem2(ORDER_CHILD, ID, x, y, lx, ly)
		{
		}		
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new BMenuField( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", NULL, new BPopUpMenu(\"%s\"), true), %d);\n", 
				s, 
				rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.top + g_iOffsetY+20, // bottom not meaningful
				"", //pIDC
				pIDC, next
			);

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
};


class RCItem_EditText : public RCItem2 {
	public:
		RCItem_EditText(const char *ID, int x, int y, int lx, int ly) : RCItem2(ORDER_CHILD, ID, x, y, lx , ly)
		{
		}
		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;
			fprintf(fp, "\t\t\t%s = new RViewList(new BTextControl( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", NULL, \"%s\", new BMessage(%s)), %d);\n", 
			s, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			"", 
			pIDC, next
			
			);

			WriteNext(fp, first, pIDC);
			
			return true;
			
		}
};

class RCItem_CustomControl : public RCItem2 {
	public:
		RCItem_CustomControl(const char *ID, const char *className, int x, int y, int lx, int ly) 
			: RCItem2(ORDER_CHILD, ID, x, y, lx, ly)
		{
			strcpy(szClass, className);
		}

		bool Write(FILE *fp, int first, int next)
		{
			const char *s1 = "pCurrent = pFirst";
			const char *s2 = "pCurrent->next";
			const char *s = first ? s1 : s2;

			fprintf(fp, "\t\t\t%s = new RViewList(new %s( BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", new BMessage(%s)), %d);\n", 
			s, 
			szClass, 
			rect.left+ g_iOffsetX, rect.top+ g_iOffsetY, rect.right+ g_iOffsetX, rect.bottom+ g_iOffsetY, 
			pIDC, 
			pIDC, next);

			WriteNext(fp, first, pIDC);
			return true;
			
		}
		char szClass[256];
};

class RCCustomClass
{
	public:
		RCCustomClass(const char *sz)
		{
			strcpy(szClass, sz);
			pNext = 0;
		}
		void Write(FILE *fp)
		{
			fprintf(fp, "#include \"%s.h\" // Custom class\n", szClass);
			char szFile[256];
			sprintf(szFile, "%s.h", szClass);
			FILE *f = fopen(szFile,"rt");
			if (!f)
			{
				f = fopen(szFile,"wt");
			    char up[256];
				char *s = szClass, *d = up; 
				while (*s)
				{
					*d = toupper(*s);
					d++; s++;
				}
				*d = 0;

				fprintf(f,"#ifndef %s_HH\n", up);
				fprintf(f,"#define %s_HH\n", up);
				fprintf(f,"class BMessage;\n");
				fprintf(f,"class %s : public BView\n", szClass);
				fprintf(f,"{\n");
				fprintf(f,"\tpublic:\n");
				fprintf(f,"\t%s(BRect rect, const char *label, BMessage *msg);\n", szClass);
				fprintf(f,"};\n\n");				
				fprintf(f,"#endif %s_HH\n",up);
			}
			fclose(f);
		}

		RCCustomClass *pNext;
		char szClass[256];
			
};

class RCParser {
	public:
		RCParser()
		{
			pCurrent = pFirst = 0;
			pMenuFirst = pMenu = 0;
			pBitmap = new RCBitmap;			
			pIcon = new RCBitmap;
			pCustomClass = 0;
			strcpy(szOutputPath, ".");
			
		}
		~RCParser()
		{
			delete pBitmap;
			delete pIcon;
			delete pMenu;
			while (pCustomClass)
			{
				RCCustomClass *c = pCustomClass->pNext;
				delete pCustomClass;
				pCustomClass = c;
			}
		}

		void AddCustomClass(const char *szClass)
		{
			RCCustomClass *c = pCustomClass, *p = 0;
			while (c)
			{
				if (!strcmp(c->szClass, szClass))
					return ;
				p = c;
				c = c->pNext;
			}

			if (p)
			{
				p->pNext = new RCCustomClass(szClass);
			}
			else
			{
				pCustomClass = new RCCustomClass(szClass);
			}
		}

		void report_warning(const char *fmt, ...)
		{
			char buffer[1024];
			va_list argptr;
			va_start(argptr, fmt);
			vsprintf(buffer, fmt, argptr);
			va_end(argptr);
			printf("%s (%d) : Warning : %s\n", g_szCurrentFile, g_nCurrentLine, buffer);
			
		}

		void report_error(const char *fmt, ...)
		{
			char buffer[1024];
			va_list argptr;
			va_start(argptr, fmt);
			vsprintf(buffer, fmt, argptr);
			va_end(argptr);
			printf("%s (%d) : Error: %s\n", g_szCurrentFile, g_nCurrentLine, buffer);
			
		}

		FILE *OpenFile(const char *szFilename, bool bTest)
		{
			sprintf(g_szCurrentFile, "%s%s", szOutputPath, szFilename);
			if ((!bTest)||(g_bForceOverwrite))
			{
				return fopen(g_szCurrentFile, "wb");
			}
			FILE *f = fopen(g_szCurrentFile, "rt");
			if (!f)
			{
				return fopen(g_szCurrentFile, "wb");
			}
			else
				report_warning("already exists");
			fclose(f);
			return 0;
		}


		void AddMenu(RCMenu *p)
		{
			if (!pMenuFirst)
			{
				pMenuFirst = pMenu = p;
			}
			else
			{
				pMenu->pNext = p;
				pMenu = p;
			}
		}
		const char *GetString( char *dest = NULL, int maxChar = 255, bool UntilComma = true)
        {
            static char s2[256];
            char *s1 = s2;
			*s2 = 0;
			*dest = 0;

			if (EndOfBuffer())
				return 0;

			if (UntilComma)
			{
				while(GetBuffer()==',') 
					_bufferPtr++;
			}

            while (GetBuffer()<=' ')
			{
                _bufferPtr++;
				if (EndOfBuffer())
					return 0;

			}
			    
			int colade = 0;

            while(1)					
            {
				if (GetBuffer()=='&')
				{
					_bufferPtr++;
					if (GetBuffer()!='&')
						continue;
				}

				if (GetBuffer()=='\n')
				{
					_bufferPtr++;
				}

				if (GetBuffer()=='\t')
				{
					_bufferPtr++;
				}

				if (GetBuffer()=='©')
				{
					*s1 = 'Â'; s1++;
				}
				if (GetBuffer()=='®')
				{
					*s1 = 'Â'; s1++;
				}
				
				if (GetBuffer()==34)
				{
					colade^=1;					
				}
				else
				{
					*s1 = *_bufferPtr;
					s1++;
				}
                _bufferPtr++;
				if (!colade)
				{
					if (GetBuffer()==' ') 
					{
						_bufferPtr++;
						break;
					}
					else
					if (GetBuffer()==',') 
					{
						_bufferPtr++;
						break;
					}
					else
					if (GetBuffer()<=13)
					{
						break;
					}
				}
            }
            *s1 = 0;
            if (dest) 
				strncpy(dest, s2, maxChar);

            //printf("read %s\n", dest);
            return s2;
        }
		
		int GetInt()
		{
			char temp[32];
			memset(temp, 0, 32);
			GetString(temp, 32);
			return atoi(temp);			
		}
		void ReadUntil(char s)
		{
			while(1)					
			{
				if (*_bufferPtr == s)
				{
					_bufferPtr++;
					 break;
				}
				_bufferPtr++;
			}
			return;
		}
		int phase0()
		{
			char parm1[256];			
			if (!GetString(parm1, 255))
				return 0;
#ifdef _TRACE
			printf("'PHASE 0 : %s' (%d)\n", parm1, strlen(parm1));
#endif
			if (strcmp(parm1, "Dialog")==0)
				return 1;
			else
			if (strcmp(parm1, "Menu")==0)
				return 3;
			else
			if (strcmp(parm1, "Bitmap")==0)
				return 4;
			else
			if (strcmp(parm1, "Icon")==0)
				return 5;

			return 0;
		}

		void AddView(RCView *pView)
		{
			if (!pCurrent)
			{
				pCurrent = pFirst = pView;
				
			}	
			else
			{
				pCurrent->pNext = pView;
				pCurrent = pView;
			}
			pCurrent->pNext = 0;
			g_pViewRect = pCurrent->rect;
		}

		int phase1()
		{
			char parm1[256];
			char temp[256];
			*parm1 = 0;			
			
			GetString(parm1, 255); 

			if (strcmp(parm1, "//")==0)
				GetString(parm1, 255); 				

			GetString(temp, 255);
			
			int tp = 0;
			if (strcmp(temp, "DIALOG")==0)
			{
				GetString(temp, 255);			
				tp = 1;
			}
			if (strcmp(temp, "DIALOGEX")==0) 
			{
				tp = 2;
			}
			if (tp)
			{
				bool center = false;
				char title[256];
				char look[256];
				char feel[256];
				char menu[256];
				char resizemode[32];
				char expandmode[32];
				char minimode[32];
				char flags[256];
				*title = 0;
				int x, y, lx, ly;				
				x = GetInt();
				y = GetInt();
				lx = GetInt();
				ly = GetInt();
				strcpy(feel, "B_NORMAL_WINDOW_FEEL");
				strcpy(look, "B_BORDERED_WINDOW_LOOK");
				strcpy(resizemode, "B_NOT_RESIZABLE");
				strcpy(expandmode, "B_NOT_ZOOMABLE");
				strcpy(minimode, "B_NOT_MINIMIZABLE");
				*menu = 0;

				while (1)
				{					
					GetString(temp, 255);

					if (strcmp(temp, "BEGIN")==0) 
						break;

					if (strcmp(temp, "DS_CENTER")==0)
					{
						center = true;
					}					

					if (strcmp(temp, "WS_CAPTION")==0)
					{
						strcpy(look, "B_TITLED_WINDOW_LOOK");
					}
					else
					if (strcmp(temp, "MENU")==0)
					{
						GetString(temp, 255);
						strcpy(menu, temp);
					}
					else
					if (strcmp(temp, "WS_EX_TOOLWINDOW")==0)
					{						
						strcpy(look, "B_FLOATING_WINDOW_LOOK");
					}
					else
					if (strcmp(temp, "CAPTION")==0)
					{
						GetString(title, 255);						
					}
					else
					if (strcmp(temp, "WS_THICKFRAME")==0)
					{
						strcpy(resizemode, "B_RESIZABLE");
					}
					else
					if (strcmp(temp, "WS_MINIMIZEBOX")==0)
					{
						*minimode = 0;
					}
					else
					if (strcmp(temp, "DS_MODALFRAME")==0)
					{
						// Always on top
					}
					else
					if (strcmp(temp, "WS_CAPTION")==0)
					{
						strcpy(look, "B_TITLED_WINDOW_LOOK");
					}
				}
				
				sprintf(flags, "%s|%s", resizemode, expandmode);
				if (*minimode)
				{
					strcat(flags, "|");
					strcat(flags, minimode);
				}
				
				AddView(new RCView(parm1, x, y, lx, ly, title, center, look, feel, flags, menu));
				
				return 2;
			}	
			return 0;
		}
		int phase2()
		{			
			char parm1[256];
			char parm2[256];
			char parm3[256];
			char temp[256];
			GetString(parm1, 255);			
			
			if (strcmp(parm1, "END")==0)
			{				
				return 1;
			}
			bool bEnabled = true;
			int bt = 0;
			if (strcmp(parm1, "PUSHBUTTON")==0) 
				bt = 1;
			else
			if (strcmp(parm1, "DEFPUSHBUTTON")==0) 
				bt = 2;

			if (bt)
			{
				_bufferPtr = strchr(_bufferPtr, '"');
				
				GetString(parm1, 255); // String
				GetString(parm2, 255); // ID
				
				int x = GetInt();
				int y = GetInt();
				int lx = GetInt();
				int ly = GetInt();
				pCurrent->Add( new RCItem_PushButton( parm2, parm1, x, y, lx , ly, bt == 2 ? true : false, bEnabled));
			}	
			
			else
			if ((strcmp(parm1, "LTEXT")==0) || (strcmp(parm1, "RTEXT")==0) || (strcmp(parm1, "CTEXT")==0))
			{	
				
				const char *alignement = strcmp(parm1, "LTEXT")==0 ? "B_ALIGN_LEFT" :
					(strcmp(parm1, "RTEXT")==0 ? "B_ALIGN_RIGHT" : "B_ALIGN_CENTER");
				GetString(parm1, 255); // String				
				GetString(parm2, 255); // ID 				
				
				fixingWINString(parm1); // Remove & character

				int x = GetInt();
				int y = GetInt();
				int lx = GetInt();
				int ly = GetInt();
#ifdef _TRACE
				printf("Add %s (%s)", parm2, parm1);
#endif

				pCurrent->Add( new RCItem_Text( parm2, parm1, x, y, lx , ly,
					
					alignement
				) );
			}	
			else
			if (strcmp(parm1, "ICON")==0)
			{				
				GetString(parm1, 255); // ID Resource
				GetString(parm2, 255); // ID 
				int x = GetInt();
				int y = GetInt();
				int lx = GetInt();
				int ly = GetInt();
				pCurrent->Add( new RCItem_Icon( parm2, parm1, x, y, lx , ly) );
			}	
			else
			if (strcmp(parm1, "LISTBOX")==0)
			{
				GetString(parm2, 255); // ID
				int x = GetInt();
				int y = GetInt();
				int lx = GetInt();
				int ly = GetInt();
				pCurrent->Add( new RCItem_ListBox( parm2, x, y, lx , ly) );
			}
			else
			if (strcmp(parm1, "CONTROL")==0)
			{				
				GetString(parm1, 255); // String
				
				GetString(parm2, 255); // ID
				
				GetString(parm3, 255); // type
				
				char *t = temp;
				while (*_bufferPtr!=',')
				{					
					*t = *_bufferPtr;
					_bufferPtr++;				
					t++;
				}
				*t = 0;
												
				int x = GetInt();				
				int y = GetInt();
				int lx = GetInt();
				int ly = GetInt();
				bool bEnabled = true;

				if (strstr(temp, "WS_DISABLED"))
				{
					bEnabled = false;
				}

				if (strstr(temp, "BS_MULTILINE"))
				{

				}
				
				if (strstr(temp, "BS_AUTORADIOBUTTON")) 
				{
					pCurrent->Add (new RCItem_RadioButton(parm2, parm1, x, y, lx, ly, bEnabled));
				}
				else				
				if (strstr(temp, "BS_AUTOCHECKBOX")) 
				{
					pCurrent->Add (new RCItem_CheckBox(parm2, parm1, x, y, lx, ly, bEnabled));				
				}	
				else
				if (strstr(temp, "SS_BITMAP")) 
				{					
					pCurrent->Add (new RCItem_Bitmap(parm2, parm1, x, y, lx, ly));				
				}
				else
				if (strcmp(parm1, "Tree1")==0) 
				{					
					pCurrent->Add( new RCItem_OutlistBox( parm2, x, y, lx , ly));
				}
				else
				if (strcmp(parm1, "Progress1")==0) 
				{					
					pCurrent->Add( new RCItem_StatusBar( parm2, x, y, lx , ly));
				}
				else
				if (strcmp(parm1, "Slider1")==0) 
				{					
					pCurrent->Add( new RCItem_Slider( parm2, x, y, lx , ly, bEnabled));
				}
				else
				if (strcmp(parm1, "List1")==0) 
				{					
					pCurrent->Add( new RCItem_ListView( parm2, x, y, lx , ly));
				}
				else				
				{
					pCurrent->Add( new RCItem_CustomControl( parm2, parm1, x, y, lx , ly));
					AddCustomClass(parm1);
				}
				

			}
			else
			if (strcmp(parm1, "COMBOBOX")==0)
			{				
				GetString(parm2, 255); // ID
				int x = GetInt();				
				int y = GetInt();
				int lx = GetInt();
				int ly = GetInt();
				pCurrent->Add (new RCItem_ComboBox(parm2, x, y, lx, ly));
			}
			else
			if (strcmp(parm1, "EDITTEXT")==0)
			{
				GetString(parm2, 255); // ID
				int x = GetInt();				
				int y = GetInt();
				int lx = GetInt();
				int ly = GetInt();
				pCurrent->Add (new RCItem_EditText(parm2, x, y, lx, ly));
			}			
			else
			if (strcmp(parm1, "GROUPBOX")==0)
			{
				
				// Begin Group
				GetString(parm3, 255); // text
				GetString(parm2, 255); // ID
				int x = GetInt();				
				int y = GetInt();
				int lx = GetInt();
				int ly = GetInt();
				
				pCurrent->Add (new RCItem_GroupBox(parm2, parm3, x, y, lx, ly));
			}		
			
			return 2;
		}
		int phase3()
		{
			char parm1[256];
			char temp[256];
			GetString(parm1, 255);			
			GetString(temp, 255);
			GetString(parm1, 255);
			AddMenu(new RCMenu(temp));
			return 31;
		}
		char szPopupName[256];
		int phase31()
		{
			static int colade = 0;
			char temp[256];
			
			GetString(temp, 255);			

			if (strcmp(temp, line_mark)==0) 
				return 0;
			else
			if (strcmp(temp, "POPUP")==0) 
			{
				GetString(temp, 255);				
				pMenu->AddEntry(new RCMenuEntry(MN_POPUP, temp));
				strcpy(szPopupName, temp);
			}
			else
			if (strcmp(temp, "MENUITEM")==0) 
			{
				char parm1[256];
				char parm2[256];
				GetString(parm1, 255);
				
				if( strcmp(parm1, "SEPARATOR")==0)
				{
					pMenu->AddEntry(new RCMenuEntry(MN_SEPARATOR));
				}
				else
				{					
					GetString(parm2, 255, false);
					fixingWINString(parm1); // Remove & character
					fixingWINString(parm2); // Remove & character
					// printf("%s + %s\n", parm1, parm2);
					pMenu->AddEntry (new RCMenuEntry(parm2, parm1));
				}
			}
			else
			if (strcmp(temp, "BEGIN")==0) 
			{
				pMenu->AddEntry(colade ? new RCMenuEntry( MN_BEGIN , szPopupName) : new RCMenuEntry( MN_BEGINBAR, "bar") );
				colade++;
				if (colade>g_iCurrentStack) 
					g_iCurrentStack = colade;

			}
			else
			if (strcmp(temp, "END")==0) 
			{
				pMenu->AddEntry(new RCMenuEntry(MN_END));
				colade--;
				if (colade<=0) 
					return 0;
			}
			

			return 31;				
		}
		
		int phase4()
		{
			char parm1[256];
			char parm2[256];
			char temp[256];
			GetString(parm1, 255);		// Name ?	
			if (strcmp(parm1, line_mark)==0) 
				return 0;
			else
			if (strcmp(parm1, "//")) 
			{
				GetString(temp, 255); // bitmap
				if (strcmp(temp, "BITMAP")==0)
				{					
					GetString(temp, 255); // discardable
					GetString(parm2, 255); // filename;
					pBitmap->AddEntry(new RCBitmapEntry(parm1, fixingBMPFilename(parm2)));
				}
			}
			return 4;	
		}
		
		int phase5()
		{
			char parm1[256];
			char parm2[256];
			char temp[256];
			*parm1 = 0;
			*parm2 = 0;
			*temp = 0;

			GetString(parm1, 255);
			if (strcmp(parm1, line_mark)==0) 
				return 0;
			else
			{
				if (strstr(parm1, "ICON"))
				{
					GetString(temp, 255); // temp;
					GetString(temp, 255); // temp;
					GetString(parm2, 255); // temp;
					pIcon->AddEntry(new RCBitmapEntry(parm1, fixingBMPFilename(parm2)));
#ifdef _TRACE
					printf("Add icon %s\n", parm2);
#endif
				}
			}
			return 5;
		}

		int fsize(FILE *fp)
		{
			size_t curpos, length;
			curpos = ftell(fp);
			fseek(fp, 0L, SEEK_END);
			length = ftell(fp);
			fseek(fp, curpos, SEEK_SET);
			return length;
		}

		int file_readToBuffer(const char *szFilename, void **pData, size_t *length)
		{
			FILE* fp = fopen(szFilename, "rb");
			if (fp)
			{
				*length = fsize(fp);
				*pData = malloc(1+(*length));
				fread(*pData, *length, 1, fp);
				fclose(fp);
				return 0;
			}
			else
			{
				*length = 0;
				*pData = 0; 
				return -1;	
			}
		}


		bool Parse(const char *filename, const char *outputfilename)
		{
			strcpy(szOutputPath, outputfilename);
			int phase = 0;			
			
			if (file_readToBuffer(filename, (void**)&_buffer, &_bufferLength))
				return false;

			_bufferPtr = _buffer;

			while(!EndOfBuffer())
			{	
#ifdef _TRACE
				printf("phase=%d\n", phase);
#endif
				switch(phase) 
				{
					case 0:
						phase = phase0();
					break;
					case 1:
						phase = phase1();
					break;
					case 2:
						phase = phase2();
					break;
					case 3:
						phase = phase3();
					break;
					case 31:
						phase = phase31();
					break;		
					case 4:
						phase = phase4();
					break;
					case 5:
						phase = phase5();
					break;
				}
					
			}
			
			fp = OpenFile("RView.cpp", false);
			if (fp)
			{
				fprintf(fp, copyright);			

				fprintf(fp, "#include <InterfaceKit.h>\n\n");
				fprintf(fp, "#include \"RViewList.h\"\n");
			
				if (g_bHasBitmaps || g_bHasIcons)
				{
					fprintf(fp, "#include \"RBitmapLoader.h\" // File provided with BEVSRC\n");
				}

				fprintf(fp, "#include \"RView.h\"\n");			
				fprintf(fp, "#include \"afxres.h\"\n");
				fprintf(fp, "#include \"resource.h\"\n");
		

				if (pCustomClass)
				{	
					RCCustomClass *p = pCustomClass;					
					while(p)
					{
						p->Write(fp);
						p = p->pNext;
					}					
				}			

				if (g_bHasIcons)
				{
					fprintf(fp, "// Caution ! BeOS is case sensitive on filenames!\n");
					fprintf(fp, "const char *LoadIconResource(unsigned id)\n");
					fprintf(fp, "{\n");
					fprintf(fp, "\t\tswitch(id) { \n");			
					{
						
						RCBitmapEntry *p = pIcon->pFirst;					
						while(p)
						{
							p->Write(fp);
							p = p->pNext;
						}
						
					}
					fprintf(fp, "\t\t\tdefault: return NULL;\n");
					fprintf(fp, "\t\t}\n");
					fprintf(fp, "}\n");
				}

				if (g_bHasBitmaps)
				{
					fprintf(fp, "// Caution ! BeOS is case sensitive on filenames!\n");
					fprintf(fp, "const char *LoadBitmapResource(unsigned id)\n");
					fprintf(fp, "{\n");
					fprintf(fp, "\t\tswitch(id) { \n");			
					{
						RCBitmapEntry *p = pBitmap->pFirst;
						
						while(p)
						{
							p->Write(fp);
							p = p->pNext;
						}
					}
					fprintf(fp, "\t\t\tdefault: return NULL;\n");
					fprintf(fp, "\t\t}\n");
					fprintf(fp, "}\n");
				}

				fprintf(fp, "RViewList *LoadResourceView(unsigned id, void *param)\n");
				fprintf(fp, "{\n");			
				fprintf(fp, "\tswitch(id) {\n");
				
				pCurrent = pFirst;

				if (!pCurrent)
				{
					report_error("No resource\n");
				}

				while(pCurrent)
				{
					pCurrent->Write(fp);
					pCurrent = pCurrent->pNext;
				}

				fprintf(fp, "\t\tdefault:\n");
				fprintf(fp, "\t\treturn 0;\n");
				fprintf(fp, "\t}\n");
				fprintf(fp, "}\n");
				fclose(fp);
			}

			//////////////////////////////////////////////////////////////////

			fp = OpenFile("RWindow.h", false);
			if (fp)
			{
				fprintf(fp, copyright);

				fprintf(fp, "#ifndef __RWINDOW__HH\n");
				fprintf(fp, "#define __RWINDOW__HH\n");
				fprintf(fp, "#include <Window.h>\n");		
				fprintf(fp, "class BView;\n");
				fprintf(fp, "class RViewList;\n");
				fprintf(fp, "class BMessage;\n");						
				fprintf(fp, "template <unsigned ID_VALUE> class RWindow : public BWindow \n");
				fprintf(fp, "{\n");
				fprintf(fp, "\tpublic:\n");
				fprintf(fp, "\tRWindow(BRect rect, const char *pTitle, window_look look, window_feel feel, unsigned long flags, bool bIsCenter);\n");
				fprintf(fp, "\tvirtual\tbool\tQuitRequested();\n");			
				fprintf(fp, "\tvirtual\tvoid\tMessageReceived(BMessage *msg);\n");
				fprintf(fp, "\tvirtual\tbool\tOnInitDialog();\n");
				fprintf(fp, "\tvirtual\tBView\t*\tChildID(long ID);\n");
				fprintf(fp, "\tvoid\tClean();\n");
				fprintf(fp, "\tRViewList\t*\tm_List;\n");
				fprintf(fp, "};\n");

				fprintf(fp, "#endif // __RWINDOW__HH\n");		
				fclose(fp);			
			}

			//////////////////////////////////////////////////////////////////

			fp = OpenFile("RWindow.cpp", false);
			if (fp)
			{
				fprintf(fp, copyright);

				fprintf(fp, "#include <Debug.h>\n");
				fprintf(fp, "#include <InterfaceKit.h>\n");
				fprintf(fp, "#include <Application.h>\n");
				fprintf(fp, "#include \"RWindow.h\"\n");
				fprintf(fp, "#include \"RView.h\"\n");
				fprintf(fp, "#include \"RViewList.h\"\n");
				fprintf(fp, "\n");

				fprintf(fp, "template<unsigned ID_VALUE>\n");
				fprintf(fp, "RWindow<ID_VALUE>::RWindow(BRect rect, const char *pTitle, window_look look, window_feel feel, unsigned long flags, bool bIsCenter ) : BWindow(rect, pTitle, look, feel, flags)\n");
				fprintf(fp, "{\n");
				fprintf(fp, "\tm_List = LoadResourceView(ID_VALUE, 0);\n");
				fprintf(fp, "\tRViewList *ptr = m_List;\n");
				
				fprintf(fp, "\tASSERT(ptr);\n");
				fprintf(fp, "\tBRect bounds = Bounds();\n");
				fprintf(fp, "\tBView *view = new BView(bounds, \"base\", B_FOLLOW_ALL, B_WILL_DRAW);\n");
				fprintf(fp, "\tASSERT(view);\n");
				fprintf(fp, "\tview->SetViewColor(221, 221, 221);\n");
				fprintf(fp, "\tAddChild(view);\n");
				fprintf(fp, "\twhile (ptr)\n");
				fprintf(fp, "\t{\n");
				fprintf(fp, "\tif( ptr->archive) \n");
				fprintf(fp, "\t{\n");
					fprintf(fp, "\t\tif (ptr->index<0) view->AddChild(ptr->archive); \n");
					fprintf(fp, "\t\telse \n");
					fprintf(fp, "\t\t{\n");
						fprintf(fp, "\t\t\tint i;\n");
						fprintf(fp, "\t\t\tRViewList *p = m_List;\n");
						fprintf(fp, "\t\t\tfor(i=0;i<ptr->index;i++) p = p->next;\n");
						fprintf(fp, "\t\t\tp->archive->AddChild(ptr->archive);\n");
					fprintf(fp, "\t\t}\n");
				fprintf(fp, "\t}\n");
				fprintf(fp, "\t\tptr = ptr->next;\n");
				fprintf(fp, "\t}	\n");
				fprintf(fp, "\tBScreen b; bounds = b.Frame();\n");

				fprintf(fp, "\tfloat w = bounds.right, h = bounds.bottom; \n");
				fprintf(fp, "\tif (bIsCenter) MoveTo( (w - (rect.right - rect.left)) / 2, (h - (rect.bottom - rect.top)) / 2 );\n");
				fprintf(fp, "\tOnInitDialog();\n");
				fprintf(fp, "}\n");

			
			
				fprintf(fp, "//TODO : \n");
				fprintf(fp, "template<unsigned ID_VALUE>\n");
				fprintf(fp, "void RWindow<ID_VALUE>::Clean()\n");
				fprintf(fp, "{\n");
				fprintf(fp, "\twhile (m_List)\n");
				fprintf(fp, "\t{\n");
				fprintf(fp, "\t\tRViewList *next = m_List->next;\n");
				fprintf(fp, "\t\tdelete m_List;\n");
				fprintf(fp, "\t\tm_List = next;\n");
				fprintf(fp, "\t}\n");
				
				fprintf(fp, "}\n");

				fprintf(fp, "//TODO : \n");
				fprintf(fp, "template<unsigned ID_VALUE>\n");
				fprintf(fp, "bool RWindow<ID_VALUE>::QuitRequested()\n");
				fprintf(fp, "{\n");
				fprintf(fp, "\tClean();\n");
				fprintf(fp, "\treturn(true);\n");
				fprintf(fp, "}\n");

				fprintf(fp, "//TODO : Specializes this method to get IDC_xxx message.\n");
				fprintf(fp, "template<unsigned ID_VALUE>\n");
				fprintf(fp, "void RWindow<ID_VALUE>::MessageReceived(BMessage *msg)\n");
				fprintf(fp, "{\n");
				fprintf(fp, "\tswitch(msg->what) {\n");
				fprintf(fp, "\t\tdefault: BWindow::MessageReceived(msg); break;\n");
				fprintf(fp, "\t}\n");
				fprintf(fp, "}\n");

				fprintf(fp, "//TODO : Specializes this method to initializes default values at startup\n");
				fprintf(fp, "template<unsigned ID_VALUE>\n");
				fprintf(fp, "bool RWindow<ID_VALUE>::OnInitDialog()\n");
				fprintf(fp, "{\n");
				fprintf(fp, "\treturn(true);\n");
				fprintf(fp, "}\n");

				fprintf(fp, "#include \"resource.h\"\n");
				fprintf(fp, "#include \"RWindowCustom.cpp\"\n");
				fprintf(fp, "template<unsigned ID_VALUE>\n");
				fprintf(fp, "BView *RWindow<ID_VALUE>::ChildID(long ID)\n");
				fprintf(fp, "{\n");
				fprintf(fp, "\tRViewList *ptr = m_List;\n");
				
				fprintf(fp, "\tASSERT(ptr);\n");
				fprintf(fp, "\twhile (ptr)\n");
				fprintf(fp, "\t{\n");
				fprintf(fp, "\t\tif (ptr->ID == ID) return ptr->archive;\n");
				fprintf(fp, "\t\tptr = ptr->next;\n");
				fprintf(fp, "\t}	\n");
				fprintf(fp, "\treturn(NULL);\n");
				
				fprintf(fp, "}\n");

				fprintf(fp, "BWindow *LoadResource(unsigned id, void *param)\n");
				fprintf(fp, "{\n");
				fprintf(fp, "\tswitch(id) {\n");
				pCurrent = pFirst;
				while (pCurrent)
				{
					if (pCurrent->IsWindow)
					{
						fprintf(fp, "\t\tcase %s: return new RWindow<%s>(BRect(%.0f, %.0f, %.0f, %.0f), \"%s\", %s, %s, %s, %s);\n", 
							pCurrent->pIDC, 
							pCurrent->pIDC, 
							pCurrent->rect.left, 
							pCurrent->rect.top, 
							pCurrent->rect.right, 
							pCurrent->rect.bottom, 					
							pCurrent->pTitle, 	
							pCurrent->pLook, 
							pCurrent->pFeel, 
							pCurrent->pResize, 						
							pCurrent->pCenter ? "true" : "false"

						);
					}
					pCurrent = pCurrent->pNext;
				}

				fprintf(fp, "\t\tdefault: return NULL; \n");
				fprintf(fp, "\t}\n");
				fprintf(fp, "}\n");
				fprintf(fp, "BMenu *LoadMenu(unsigned id)\n");
				fprintf(fp, "{\n");

				fprintf(fp, "\tswitch(id) {\n");
				RCMenu *p = pMenuFirst;
				while (p)
				{
					p->Write(fp);		
					p = p->pNext;
				}
				fprintf(fp, "\t\tdefault : return 0;\n");
				fprintf(fp, "\t}\n");			
				fprintf(fp, "}\n");
				
				fclose(fp);
			
			}

			//////////////////////////////////////////////////////////////////


			fp = OpenFile("RWindowCustom.cpp", true);
			if (fp)
			{
				fprintf(fp, copyright);
				fclose(fp);
			}			

			if (pFirst)
			{
				fp = OpenFile("RApplication.cpp", true);
				if (fp)
				{
					fprintf(fp, copyright);

					fprintf(fp, "#include \"RWindow.h\"\n");
					fprintf(fp, "#include \"RView.h\"\n");
					fprintf(fp, "#include \"RApplication.h\"\n");
					fprintf(fp, "#include \"resource.h\"\n");

					fprintf(fp, "int main(int, char**)\n");
					fprintf(fp, "{	\n");
					fprintf(fp, 	"\t// Create an application instance\n");
					fprintf(fp, 	"\tRApplication myApplication;\n\n");					
					fprintf(fp, 	"\t// Run the application looper\n");
					fprintf(fp, 	"\tmyApplication.Run();\n");
					fprintf(fp, 	"\treturn(0);\n");
					fprintf(fp, "}\n");

					fprintf(fp, "// RApplication constructor\n");
					fprintf(fp, "RApplication::RApplication() : BApplication(\"application/x-vnd.Be-Sample\")\n");
					fprintf(fp, "{\n");
					fprintf(fp, "\tBWindow *pWindow = LoadResource(%s, 0);\n", pFirst->pIDC);
					fprintf(fp, "\tpWindow->Show();\n");
					
					fprintf(fp, "}\n");

					fclose(fp);					
				}			
				
			}
			
			fp = OpenFile("RApplication.h", true);
			if (fp)
			{
				fprintf(fp, copyright);

				fprintf(fp, "#ifndef __RAPPLICATION__HH\n");
				fprintf(fp, "#define __RAPPLICATION__HH\n");


				fprintf(fp, "#include <Application.h>\n");
				fprintf(fp, "class RApplication : public BApplication\n");
				fprintf(fp, "{\n");
				fprintf(fp, "public:\n");
				fprintf(fp, "\tRApplication();\n");
				fprintf(fp, "};\n");

				fprintf(fp, "#endif // __RAPPLICATION__HH\n");		
				fclose(fp);	
			}


			pCurrent = pFirst;
			while (pCurrent)
			{
				RCView *pNext = pCurrent->pNext;
				delete pCurrent;
				pCurrent = pNext;
			}
			free(_buffer);
			
			return true;
			
		}
		bool		EndOfBuffer() { return _bufferPtr>=_buffer+_bufferLength;}
		char		GetBuffer() { assert(!EndOfBuffer()); return *_bufferPtr; }

		size_t		  _bufferLength;
		char		*_bufferPtr;		
		char		*_buffer;
		FILE		*fp;
		RCView		*pCurrent;
		RCView		*pFirst;
		RCBitmap	*pBitmap, *pIcon;
		RCMenu		*pMenu, *pMenuFirst;
		RCCustomClass	*pCustomClass;
		char szOutputPath[256];

};





int ProcessFile(const char *szFilename, const char *outputPath)
{
	RCParser parser;
	strcpy(g_szCurrentFile, szFilename);
	g_nCurrentLine = 0;
	if (!parser.Parse(szFilename, outputPath)) 
	{
		parser.report_error("read error");
	}
	return false;
	return true;
}

int 
main(int argc, char **argv)
{
	char outputdir[256];
	strcpy(outputdir,".");
	printf(__BUILD__"\n");	
	if (argc==1)
	{
		printf("Win32 RC file to BeOS Interface Kit source compiler.\n");		
		printf("BeOS is a registred trademark of Be Incorporated\n\n");
		printf("Usage : w32rc2be filename.rc <option>\n");
		printf("Option: -ooutputdir : Set output dir (default .)\n");
		printf("        -f          : force overwrite\n");
		
		return 0;
	}	
	int i;
	for (i=2;i<argc;i++)
	{
		const char *arg  = argv[i];
		if (arg[0]=='-')
		{
			if (arg[1] == 'o')
			{
				strcpy(outputdir, arg+2);
			}
			if (arg[1] == 'f')
			{
				g_bForceOverwrite = true;
			}
		}
	}
	if (outputdir[strlen(outputdir)-1]!='/')
		strcat(outputdir,"/");
	
	ProcessFile(argv[1], outputdir);
	return 1;
}

